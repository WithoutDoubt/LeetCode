给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字符的最小子串。



> 移动right，c = s[right]
>
> 如果need中需要c，那么 window[c]++,
>
> 如果window[c] == need[c] , 表示 c 这个字符已经在need中的数目已经够了，更新valid，valid++
>
>
>
> 如果，valid == need.size()，说明区间已经满足
>
> 更新结果，【因为移动左边后可能不满足了】
>
> 保存最左边的字符 c2
>
> 移动左边，
>
> 如果 need[c2] 是存在的
>
> ​     win[c2]--;
>
> ​     那么如果win[c2] == need[c2],  valid--;  说明c2字符不满足【可能一开始c2数目大于需要的数目】
>
> ​     







```c++

```

